Software dynamics refers not just to the performance or execution time of a single program thread but to the interactions between threads, between unrelated programs, and between an operating system and user programs. Delays in complex software often are caused by these interactions—code blocking and waiting for other code to wake it up, runnable code waiting for the scheduler to assign it a CPU to run on, code running slowly due to shared-hardware interference from other code, code not running at all because an interrupt routine is using its CPU, code invisibly spending much of its time in operating-system services or in page-fault handling, code waiting for I/O devices or network messages from other computers, and so on.

Book material is organized into four parts, including a part about building the low-overhead KUtrace observation tool:
1. Part I (Chapters 1–7), Measurement—how to do careful measurements of the four fundamental computer resources: CPU, memory, disk/SSD, and network.
2. Part II (Chapters 8–13), Observation—normal observation tools: logging, dashboards, counting/profiling/sampling, and tracing.
3. Part III (Chapters 14–19), Kernel-User Trace—the design and construction of a running low-overhead Linux tracing tool that records what every CPU core is doing every nanosecond, along with postprocessing programs to create dynamic HTML pages that display the resulting timelines and interactions.
4. Part IV (Chapters 20–30), Reasoning—case studies of reasoning about the interference underlying unusual delays observed in: excess execution, slow instruction execution, waiting for CPU, memory, disk, network, software locks, queues, and timers.